open Astring
open Rresult.R.Infix

module Lang = struct
  type version = int * int

  let ord = function 0 -> `Eq | i when i < 0 -> `Lt | _ -> `Gt

  let compare_version (major, minor) (major', minor') =
    match Int.compare major major' with 0 -> ord (Int.compare minor minor') | x -> ord x

  let pp_version fmt (major, minor) = Format.fprintf fmt "%d.%d" major minor

  let parse_version s =
    let err () = Error (`Msg (Printf.sprintf "Invalid dune lang version: %s" s)) in
    match String.cuts ~sep:"." s with
    | [ major; minor ] -> (
        match (int_of_string major, int_of_string minor) with
        | major, minor -> Ok (major, minor)
        | exception _ -> err () )
    | _ -> err ()

  let parse_stanza s =
    let content =
      String.cuts ~sep:" " (String.trim ~drop:(function '(' | ')' -> true | _ -> false) s)
    in
    match content with
    | [ "lang"; "dune"; version ] -> parse_version version
    | _ -> Error (`Msg (Printf.sprintf "Invalid lang stanza: %s" s))

  let is_stanza s = String.is_prefix ~affix:"(lang " s

  let duniverse_minimum_version = (1, 11)

  let stanza version = Format.asprintf "(lang dune %a)" pp_version version
end

module Raw = struct
  let comment s = Printf.sprintf "; %s" s

  let vendored_dirs glob = Printf.sprintf "(vendored_dirs %s)" glob

  let duniverse_dune_content =
    [
      comment "This file is generated by duniverse.";
      comment "Be aware that it is likely to be overwritten by your next duniverse pull invocation.";
      "";
      vendored_dirs "*";
    ]

  let duniverse_minimum_lang = Lang.stanza Lang.duniverse_minimum_version
end

module Project = struct
  module OV = Ocaml_version

  let load_dune_project () =
    match Sexplib.Sexp.load_sexps "dune-project" with
    | v -> Ok v
    | exception exn -> Error (`Msg (Printexc.to_string exn))

  let check_opam_generation =
    let open Sexplib.Sexp in
    List.exists (function List [ Atom "generate_opam_files"; Atom "true" ] -> true | _ -> false)

  let compare_ov a b op =
    let b = OV.of_string_exn b in
    match (OV.compare a b, op) with
    | -1, ("<=" | "<" | "<>") -> true
    | 0, ("<=" | "=" | ">=") -> true
    | 0, "<>" -> false
    | 1, (">=" | ">" | "<>") -> true
    | _ -> false

  let eval_ocaml_bcomp sxp ov =
    let open Sexplib.Sexp in
    let rec eval = function
      | List (Atom "and" :: tl) -> List.fold_left (fun a b -> eval b && a) true tl
      | List (Atom "or" :: tl) -> List.fold_left (fun a b -> eval b || a) false tl
      | List [ Atom "not"; a ] -> not (eval a)
      | List [ Atom ((">=" | ">" | "=" | "<" | "<=" | "<>") as op); Atom a ] -> compare_ov ov a op
      | List _ -> failwith "unexpected list atoms, only ne/and/or/not supported"
      | Atom _ -> true
    in
    eval sxp

  let supported_ocaml_compilers () =
    let open Sexplib.Sexp in
    load_dune_project () >>= fun sxp ->
    (* Check that opam file generation is on, and warn otherwise *)
    match check_opam_generation sxp with
    | false ->
        Error
          (`Msg
            "Duniverse requires you to have (generate_opam_files true) in your dune-project, so \
             that it can infer the supported OCaml versions from your package constraints. Please \
             see https://dune.readthedocs.io/en/stable/opam.html#generating-opam-files")
    | true ->
        let constr =
          List.filter_map
            (function
              | List (Atom "package" :: prsxp) -> (
                  List.filter_map
                    (function List (Atom "depends" :: depsxp) -> Some depsxp | _ -> None)
                    prsxp
                  |> function
                  | [] -> None
                  | depsxp :: _ -> (
                      List.filter_map
                        (function
                          | Atom "ocaml" -> Some []
                          | List (Atom "ocaml" :: ocsxp) -> Some ocsxp
                          | _ -> None)
                        depsxp
                      |> function
                      | [] -> None
                      | res :: _ -> Some res ) )
              | _ -> None)
            sxp
          |> List.flatten
        in
        let constr = List (Atom "and" :: constr) in
        let r = List.filter (eval_ocaml_bcomp constr) OV.Releases.all in
        Ok r
end
